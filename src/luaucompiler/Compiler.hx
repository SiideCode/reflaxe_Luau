package luaucompiler;

// Make sure this code only exists at compile-time.
import reflaxe.helpers.Context;
#if (macro || luau_runtime)
// Import relevant Haxe macro types.
import haxe.macro.Type;
// Import Reflaxe types
import reflaxe.DirectToStringCompiler;
import reflaxe.data.ClassFuncData;
import reflaxe.data.ClassVarData;
import reflaxe.data.EnumOptionData;
import luaucompiler.utils.Utils;

using StringTools;

/**
	The class used to compile the Haxe AST into your target language's code.

	This must extend from `BaseCompiler`. `PluginCompiler<T>` is a child class
	that provides the ability for people to make plugins for your compiler.
**/
class Compiler extends DirectToStringCompiler {
	/**
		This is the function from the BaseCompiler to override to compile Haxe classes.
		Given the haxe.macro.ClassType and its variables and fields, return the output String.
		If `null` is returned, the class is ignored and nothing is compiled for it.

		https://api.haxe.org/haxe/macro/ClassType.html
	**/
	public function compileClassImpl(classType:ClassType, varFields:Array<ClassVarData>, funcFields:Array<ClassFuncData>):Null<String> {
		// TODO: implement
		if (classType.isExtern) {
			return null;
		}

		var ret = "";

		if (!Context.defined("noWatermark")) {
			ret += "-- Generated by reflaxe.Luau v" + (Context.defined("reflaxe_Luau") ? Context.definedValue("reflaxe_Luau") : " Dev") + "\n";
		}

		if (classType.doc != null) {
			ret += Utils.convertDocToLuau(classType.doc);
		}

		// class declaration
		ret += classType.name + " = " + "{}" + "\n";

		for (i in varFields) {
			if (i.isStatic) {
				trace(i.field.name);
				if (i.field.doc != null) {
					ret += Utils.convertDocToLuau(i.field.doc);
				}
			}
		}

		var construct;
		if (classType.constructor != null) {
			construct = classType.constructor.get();
			if (construct.doc != null) {
				ret += Utils.convertDocToLuau(construct.doc);
			}
			ret += "function " + classType.name + ".new(";

			for (i => k in construct.params) {
				ret += k.name + ":" + Utils.typeToString(k.t);

				if (i != construct.params.length - 1)
					ret += ", ";
			}

			ret += ")\n";

			ret += "local instance = {}\n";

			// do constructor stuff, add non-static vars

			ret += "setmetatable(instance, " + classType.name + ")\n";

			ret += "end";
		}

		return ret;
	}

	/**
		Works just like `compileClassImpl`, but for Haxe enums.
		Since we're returning `null` here, all Haxe enums are ignored.

		https://api.haxe.org/haxe/macro/EnumType.html
	**/
	public function compileEnumImpl(enumType:EnumType, constructs:Array<EnumOptionData>):Null<String> {
		// TODO: implement
		return null;
	}

	/**
		This is the final required function.
		It compiles the expressions generated from Haxe.

		PLEASE NOTE: to recusively compile sub-expressions:
			BaseCompiler.compileExpression(expr: TypedExpr): Null<String>
			BaseCompiler.compileExpressionOrError(expr: TypedExpr): String

		https://api.haxe.org/haxe/macro/TypedExpr.html
	**/
	public function compileExpressionImpl(expr:TypedExpr, topLevel:Bool):Null<String> {
		// TODO: implement
		switch (expr.expr) {
			default:
				trace(expr.expr.getName());
				trace(expr.pos);
		}
		return null;
	}
}
#end
